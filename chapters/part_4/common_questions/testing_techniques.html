<html>
  <title>Подходы к тестированию</title>
  <head>
    <link href="../../../fonts/alice.css" rel="stylesheet">
    <link href="../../../css/book.css" rel="stylesheet">
    <link href="../../../css/my-styles.css" rel="stylesheet">
    
    <style>
      
    </style>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-160621550-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-160621550-1');
    </script>
  </head>
  <body>
    <div class="chapter-toc-container">
        <h2 class="chapter-toc"><a href="../../../index.html">к Оглавлению</a></h2>
        <h1 class="chapter-toc">Общие вопросы</h1>
        <ul class="chapter-toc">
          <li class="chapter-toc"><a href="what_is_testing.html">Что такое тестирование</a></li>
          <li class="chapter-toc current"><a href="testing_techniques.html">Подходы к тестированию</a></li>
        </ul>
        <br>
        <!--h2 class="chapter-toc">Далее: Умонастроение</h2-->
    </div>
      <div class="chapter-container">
        <a href="../../../index.html" class="mobile-toc">Оглавление</a>
        <h1 class="chapter">Подходы к тестированию</h1>
        <p class="first_paragraph">
            Существует два подхода, или две техники тестирования: статическое тестирование и динамическое тестирование.
        </p>
        <p>
            На практике мы используем оба этих подхода при решении каждой задачи тестирования. Поэтому понимание того, что собой представляют эти подходы, какие у них различия, какие сильные и слабые стороны, помогает нам применять их более взвешенно в каждой конкретной задаче. Поехали!
        </p>

        <h2 class="chapter">Статическое тестирование</h2>
        <p class="definition">
            <b>Статическое тестирование</b> &mdash; это тестирование, при котором программу <u>не</u> запускают (код программы <u>не</u> исполняют).
        </p>
        <p class="first_paragraph">
            Как же можно тестировать программу без ее запуска? А очень даже по-разному!
        </p>
        <p>
            Тестировать программу без запуска можно:
            <ul>
                <li>чтением требований и спецификаций;</li>
                <li>участием в любых видах совещаний (митингах), на которых обсуждают эту программу или задачи, по которым эту программу будут делать;</li>
                <li>в процессе код-ревью;</li>
                <li>с помощью статических анализаторов кода.</li>
            </ul>
        </p>
        <p>
            В результате статического тестирования у нас может появиться в той или иной форме (как в виде конкретных артефактов, так и в виде умопредставлений): тестовая стратегия, план тестирования (тест-план) и сценарии тестирования (тест-кейсы). Эти артефакты мы далее используем в динамическом тестировании.</p>
        <p>
            Предлагаю задержаться и поподробней рассмотреть каждый из приведенных примеров статического тестирования.
        </p>

        <h3 class="chapter">Чтение требований и спецификаций</h3>
        <p>
            Когда мы знакомимся с тем, что должна делать программа (это описывают в требованиях), и тем, как именно она должна быть сделана (это описывают в спецификациях), то мы пытаемся нарисовать себе картину того, как будет работать эта программа. И, поэтому, мы уже можем начать анализировать особенности всего жизненного цикла программы: от установки (инсталляции), через ее запуск, до ее штатной или нештатной остановки (падения) и вплоть до удаления (деинсталляции), если это требуется.
        </p>
        <p class="reference">
            Подробнее о том, что такое требования и спецификации, а также чем они отличаются друг от друга, читайте в главе <...>.
        </p>
        <h3 class="chapter">Участие в совещаниях</h3>
        <p>
            Участие в любых видах совещаний: будь то звонки, запланированные личные встречи, планирование спринта (собрание, на котором обсуждают программу или задачи, по которым эту программу будут делать) &mdash; является существенным источником информации о том, что именно ожидают от программы, о том, как эти ожидания планируют реализовать или то как их уже реализовали. Из этих обсуждений обычно узнаешь, какие есть сложности и ограничения, в чем могут быть проблемы при тестировании, задаешь любые другие интересующие тебя вопросы и т.д. И это все &mdash; тоже тестирование!
        </p>
        
        <h3 class="chapter">Код-ревью</h3>
        <p class="definition">
        <b>Код-ревью</b> &mdash; это такая практика, когда один специалист читает и анализирует код, написанный другим специалистом, с целью повысить качество как написанного кода, так и работы программы.
        </p>
        <p>
            В определении я использовал слово &laquo;специалист&raquo;, а не &laquo;программист&raquo;, потому что код и программы пишут не только профессиональные программисты (SD). Код и программы могут писать: тестировщики (QA), специалисты по эксплуатации (OPS), сетевые администраторы (IT), и т.д. Поэтому все IT-специалисты, в какой-то степени, могут читать код, делая, тем самым, код-ревью.
        </p>
        <p>
            Разумеется, тестировщик не сможет сделать, например, для кода, написанного на С++, такое же глубокое код-ревью, как С++ разработчик. Но зато, читая код программы, тестировщик сможет гораздо лучше понять, как устроена программа, какие условия работы программы обработаны, а какие нет, на что стоит обратить больше внимания при тестировании, а на что можно меньше. Тестировщик может задавать разработчику какие-то вопросы по коду программы, а разработчик, отвечая на них, может обнаружить какую-то проблему, какое-то условие, которое он не учел. Последнее происходит на практике время от времени.
        </p>
        <p>
            Процедура код-ревью также помогает увидеть, что именно поменялось от версии к версии программы. И современные инструменты контроля версий помогают нам это увидеть максимально наглядно:<br>
            <img src="../../../img/example-code-review.png" style="margin-top: 1rem;"><br>
            <span class="explain-picture">
                На рисунке показано, как GitHub отображает, что именно изменилось по сравнению с предыдущей версией кода программы: значение параметра "font-size" (размер шрифта) поменяли с 1.2em на 1em.
            </span>
        </p>

        <h3 class="chapter">Статические анализаторы кода</h3>
        <p>
            Люди, которые пишут код, по различным причинам допускают ошибки. Причины ошибок могут быть самыми разными: от низкой квалификации специалиста до банальной усталости и, поэтому, невнимательности. Так или иначе, среди тех ошибок, которые они допускают, существуют типовые ошибки. А т.к. эти ошибки типовые, то их можно выявлять автоматизированным способом. Поэтому программисты всего мира, пишущие на самых разных языках программирования, создают и поддерживают так называемые &laquo;статические анализаторы кода&raquo;. 
        </p>
        <p>
            Статические анализаторы кода &mdash; это такие программы, которые на вход принимают исходный код других программ, а на выходе выдают рекомендации по улучшению кода этих программ. При этом, никакие программы из исходного кода не компилируются и не запускаются.
        </p>
        <p>
            Статические анализаторы кода встраивают в процессы работы с репозиторием удобным для команды способом. Это может быть как запуск анализатора у разработчика на компьютере в ручном режиме время от времени, так и автоматический запуск на сервере, запускающем автоматические тесты при каждом коммите в репозиторий. Все зависит от того, насколько это необходимо команде.
        </p>

        <h2 class="chapter">Динамическое тестирование</h2>
        <p class="definition">
            <b>Динамическое тестирование</b> &mdash; это тестирование, при котором программу запускают (код программы исполняют).
        </p>
        <p>
            Несмотря на то, что статическое тестирование важно, одного его недостаточно, чтобы создать необходимый уровень уверенности в том, что программа действительно работает так, как мы того ожидаем. Да, мы посмотрели на код. Да, мы видим, что он делает то, что нам надо, и не делает то, чего нам не надо. Но, дело в том, что, когда мы запустим программу, до исполнения этого кода дело может и не дойти. Программа может не запуститься, может пойти по другому условию в коде и никогда не прийти в эту часть кода, может &laquo;упасть&raquo; по пути, и т.д. И единственный (единственный!) способ убедиться в том, что программа будет исполнять наш код, что программа будет делать то, что мы от нее хотим и делать так, как мы это хотим &mdash; это запустить ее и убедиться в этом во время ее работы.
        </p>
        <p>
            Во время динамического тестирования мы проверяем в реальности все те наши гипотезы о работе программы, которые мы выдвинули во время статического тестирования. Во время статического тестирования мы создали (в виде документов и/или в виде умопредставлений) набор артефактов: тестовую стратегию, план тестирования, тестовые сценарии &mdash; и теперь мы пользуемся ими, чтобы проверить корректность работы нашей программы.
        </p>
        <p>
            Во время динамического тестирования мы проверяем:
            <ul>
                <li>запуск программы;</li>
                <li>непосредственно работу программы;</li>
                <li>штатное завершение работы программы;</li>
                <li>нештатное завершение работы программы.</li>
            </ul>    
        </p>
        <br><br><br>
        </div>

      </div>

        <script>
          window.intercomSettings = {
            app_id: "my9b0vp1"
          };
        </script>
        <script>(function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',intercomSettings);}else{var d=document;var i=function(){i.c(arguments)};i.q=[];i.c=function(args){i.q.push(args)};w.Intercom=i;function l(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/my9b0vp1';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);}if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})()</script>
  </body>
</html>



